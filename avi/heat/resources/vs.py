# GENERATED FILE - DO NOT EDIT THIS FILE UNLESS YOU ARE A WIZZARD
#pylint:  skip-file
from heat.engine import properties
from heat.engine import constraints
from heat.engine import attributes
from heat.common.i18n import _
from avi.heat.avi_resource import AviResource
from avi.heat.avi_resource import AviNestedResource
from options import *

from common import *
from options import *
from pool import *
from debug_se import *
from analytics_policy import *
from vs_datascript import *
from application_policy import *
from auth import *
from rate import *
from gslb import *
from dns import *
from content_rewrite_profile import *


class ServicePoolSelector(object):
    # all schemas
    service_port_schema = properties.Schema(
        properties.Schema.NUMBER,
        _("Pool based destination port"),
        required=True,
        update_allowed=True,
    )
    service_pool_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _(" You can either provide UUID or provide a name with the prefix 'get_avi_uuid_by_name:', e.g., 'get_avi_uuid_by_name:my_obj_name'."),
        required=False,
        update_allowed=True,
    )
    service_protocol_schema = properties.Schema(
        properties.Schema.STRING,
        _("Destination protocol to match for the pool selection. If not specified, it will match any protocol."),
        required=False,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['PROTOCOL_TYPE_TCP_FAST_PATH', 'PROTOCOL_TYPE_TCP_PROXY', 'PROTOCOL_TYPE_UDP_FAST_PATH']),
        ],
    )
    service_pool_group_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _(" You can either provide UUID or provide a name with the prefix 'get_avi_uuid_by_name:', e.g., 'get_avi_uuid_by_name:my_obj_name'."),
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'service_port',
        'service_pool_uuid',
        'service_protocol',
        'service_pool_group_uuid',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'service_port': service_port_schema,
        'service_pool_uuid': service_pool_uuid_schema,
        'service_protocol': service_protocol_schema,
        'service_pool_group_uuid': service_pool_group_uuid_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'service_pool_uuid': 'pool',
        'service_pool_group_uuid': 'poolgroup',
    }

    unique_keys = {
        'my_key': 'service_port,service_protocol',
    }



class VirtualServiceResource(object):
    # all schemas
    num_vcpus_schema = properties.Schema(
        properties.Schema.NUMBER,
        _(""),
        required=False,
        update_allowed=True,
    )
    memory_schema = properties.Schema(
        properties.Schema.NUMBER,
        _(""),
        required=False,
        update_allowed=True,
    )
    is_exclusive_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _(""),
        required=False,
        update_allowed=True,
    )
    scalein_primary_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _(""),
        required=False,
        update_allowed=True,
    )
    num_se_schema = properties.Schema(
        properties.Schema.NUMBER,
        _(""),
        required=False,
        update_allowed=True,
    )
    scalein_se_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=False,
        update_allowed=True,
    )
    num_standby_se_schema = properties.Schema(
        properties.Schema.NUMBER,
        _(""),
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'num_vcpus',
        'memory',
        'is_exclusive',
        'scalein_primary',
        'num_se',
        'scalein_se_uuid',
        'num_standby_se',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'num_vcpus': num_vcpus_schema,
        'memory': memory_schema,
        'is_exclusive': is_exclusive_schema,
        'scalein_primary': scalein_primary_schema,
        'num_se': num_se_schema,
        'scalein_se_uuid': scalein_se_uuid_schema,
        'num_standby_se': num_standby_se_schema,
    }



class Service(object):
    # all schemas
    port_schema = properties.Schema(
        properties.Schema.NUMBER,
        _("The Virtual Service's port number."),
        required=True,
        update_allowed=True,
    )
    enable_ssl_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _("Enable SSL termination and offload for traffic from clients."),
        required=False,
        update_allowed=True,
    )
    override_network_profile_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("Override the network profile for this specific service port. You can either provide UUID or provide a name with the prefix 'get_avi_uuid_by_name:', e.g., 'get_avi_uuid_by_name:my_obj_name'."),
        required=False,
        update_allowed=True,
    )
    port_range_end_schema = properties.Schema(
        properties.Schema.NUMBER,
        _("The end of the Virtual Service's port number range."),
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'port',
        'enable_ssl',
        'override_network_profile_uuid',
        'port_range_end',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'port': port_schema,
        'enable_ssl': enable_ssl_schema,
        'override_network_profile_uuid': override_network_profile_uuid_schema,
        'port_range_end': port_range_end_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'override_network_profile_uuid': 'networkprofile',
    }



class PerformanceLimits(object):
    # all schemas
    max_concurrent_connections_schema = properties.Schema(
        properties.Schema.NUMBER,
        _("The maximum number of concurrent client conections allowed to the Virtual Service."),
        required=False,
        update_allowed=True,
    )
    max_throughput_schema = properties.Schema(
        properties.Schema.NUMBER,
        _("The maximum throughput per second for all clients allowed through the client side of the Virtual Service."),
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'max_concurrent_connections',
        'max_throughput',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'max_concurrent_connections': max_concurrent_connections_schema,
        'max_throughput': max_throughput_schema,
    }



class SidebandProfile(object):
    # all schemas
    ip_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=IpAddr.properties_schema,
        required=True,
        update_allowed=False,
    )
    ip_schema = properties.Schema(
        properties.Schema.LIST,
        _("IP Address of the sideband server."),
        schema=ip_item_schema,
        required=False,
        update_allowed=True,
    )
    sideband_max_request_body_size_schema = properties.Schema(
        properties.Schema.NUMBER,
        _("Maximum size of the request body that will be sent on the sideband."),
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'ip',
        'sideband_max_request_body_size',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'ip': ip_schema,
        'sideband_max_request_body_size': sideband_max_request_body_size_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'ip': getattr(IpAddr, 'field_references', {}),
    }

    unique_keys = {
        'ip': getattr(IpAddr, 'unique_keys', {}),
    }



class TLSTicket(object):
    # all schemas
    name_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=True,
    )
    aes_key_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=True,
    )
    hmac_key_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'name',
        'aes_key',
        'hmac_key',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'name': name_schema,
        'aes_key': aes_key_schema,
        'hmac_key': hmac_key_schema,
    }



class IPNetworkSubnet(object):
    # all schemas
    network_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("Network for VirtualService IP allocation with Vantage as the IPAM provider. Network should be created before this is configured. You can either provide UUID or provide a name with the prefix 'get_avi_uuid_by_name:', e.g., 'get_avi_uuid_by_name:my_obj_name'."),
        required=False,
        update_allowed=True,
    )
    subnet_schema = properties.Schema(
        properties.Schema.MAP,
        _("Subnet for VirtualService IP allocation with Vantage or Infoblox as the IPAM provider. Only one of subnet or subnet_uuid configuration is allowed."),
        schema=IpAddrPrefix.properties_schema,
        required=False,
        update_allowed=True,
    )
    subnet_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("Subnet UUID or Name or Prefix for VirtualService IP allocation with AWS or OpenStack as the IPAM provider. Only one of subnet or subnet_uuid configuration is allowed."),
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'network_uuid',
        'subnet',
        'subnet_uuid',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'network_uuid': network_uuid_schema,
        'subnet': subnet_schema,
        'subnet_uuid': subnet_uuid_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'subnet': getattr(IpAddrPrefix, 'field_references', {}),
        'network_uuid': 'network',
    }

    unique_keys = {
        'subnet': getattr(IpAddrPrefix, 'unique_keys', {}),
    }



class VsSeVnic(object):
    # all schemas
    mac_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=True,
    )
    type_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['VNIC_TYPE_BE', 'VNIC_TYPE_INT_PRIMARY', 'VNIC_TYPE_INT', 'VNIC_TYPE_FE', 'VNIC_TYPE_INT_SECONDARY']),
        ],
    )
    lif_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'mac',
        'type',
        'lif',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'mac': mac_schema,
        'type': type_schema,
        'lif': lif_schema,
    }



class VsApicExtension(object):
    # all schemas
    txn_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=True,
    )
    se_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=False,
        update_allowed=True,
    )
    vnic_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=VsSeVnic.properties_schema,
        required=True,
        update_allowed=False,
    )
    vnic_schema = properties.Schema(
        properties.Schema.LIST,
        _(""),
        schema=vnic_item_schema,
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'txn_uuid',
        'se_uuid',
        'vnic',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'txn_uuid': txn_uuid_schema,
        'se_uuid': se_uuid_schema,
        'vnic': vnic_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'vnic': getattr(VsSeVnic, 'field_references', {}),
    }

    unique_keys = {
        'vnic': getattr(VsSeVnic, 'unique_keys', {}),
    }



class SeVipInterfaceList(object):
    # all schemas
    vip_intf_mac_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=True,
    )
    vlan_id_schema = properties.Schema(
        properties.Schema.NUMBER,
        _(""),
        required=False,
        update_allowed=True,
    )
    vip_intf_ip_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=IpAddr.properties_schema,
        required=False,
        update_allowed=True,
    )
    is_portchannel_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _(""),
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'vip_intf_mac',
        'vlan_id',
        'vip_intf_ip',
        'is_portchannel',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'vip_intf_mac': vip_intf_mac_schema,
        'vlan_id': vlan_id_schema,
        'vip_intf_ip': vip_intf_ip_schema,
        'is_portchannel': is_portchannel_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'vip_intf_ip': getattr(IpAddr, 'field_references', {}),
    }

    unique_keys = {
        'vip_intf_ip': getattr(IpAddr, 'unique_keys', {}),
    }



class SeList(object):
    # all schemas
    se_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _(" You can either provide UUID or provide a name with the prefix 'get_avi_uuid_by_name:', e.g., 'get_avi_uuid_by_name:my_obj_name'."),
        required=True,
        update_allowed=True,
    )
    is_primary_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _(""),
        required=False,
        update_allowed=True,
    )
    is_standby_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _(""),
        required=False,
        update_allowed=True,
    )
    is_connected_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _(""),
        required=False,
        update_allowed=True,
    )
    delete_in_progress_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _(""),
        required=False,
        update_allowed=True,
    )
    vcpus_schema = properties.Schema(
        properties.Schema.NUMBER,
        _(""),
        required=False,
        update_allowed=True,
    )
    memory_schema = properties.Schema(
        properties.Schema.NUMBER,
        _(""),
        required=False,
        update_allowed=True,
    )
    vip_intf_mac_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=False,
        update_allowed=True,
    )
    vip_subnet_mask_schema = properties.Schema(
        properties.Schema.NUMBER,
        _(""),
        required=False,
        update_allowed=True,
    )
    vnic_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=VsSeVnic.properties_schema,
        required=True,
        update_allowed=False,
    )
    vnic_schema = properties.Schema(
        properties.Schema.LIST,
        _(""),
        schema=vnic_item_schema,
        required=False,
        update_allowed=True,
    )
    pending_download_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _(""),
        required=False,
        update_allowed=True,
    )
    sec_idx_schema = properties.Schema(
        properties.Schema.NUMBER,
        _(""),
        required=False,
        update_allowed=True,
    )
    download_selist_only_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _(""),
        required=False,
        update_allowed=True,
    )
    vlan_id_schema = properties.Schema(
        properties.Schema.NUMBER,
        _(""),
        required=False,
        update_allowed=True,
    )
    snat_ip_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=IpAddr.properties_schema,
        required=False,
        update_allowed=True,
    )
    vip_intf_ip_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=IpAddr.properties_schema,
        required=False,
        update_allowed=True,
    )
    vip_intf_list_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=SeVipInterfaceList.properties_schema,
        required=True,
        update_allowed=False,
    )
    vip_intf_list_schema = properties.Schema(
        properties.Schema.LIST,
        _(""),
        schema=vip_intf_list_item_schema,
        required=False,
        update_allowed=True,
    )
    floating_intf_ip_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=IpAddr.properties_schema,
        required=True,
        update_allowed=False,
    )
    floating_intf_ip_schema = properties.Schema(
        properties.Schema.LIST,
        _(""),
        schema=floating_intf_ip_item_schema,
        required=False,
        update_allowed=True,
    )
    is_portchannel_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _(""),
        required=False,
        update_allowed=True,
    )
    scalein_in_progress_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _(""),
        required=False,
        update_allowed=True,
    )
    admin_down_requested_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _(""),
        required=False,
        update_allowed=True,
    )
    at_curr_ver_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _(""),
        required=False,
        update_allowed=True,
    )
    version_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'se_uuid',
        'is_primary',
        'is_standby',
        'is_connected',
        'delete_in_progress',
        'vcpus',
        'memory',
        'vip_intf_mac',
        'vip_subnet_mask',
        'vnic',
        'pending_download',
        'sec_idx',
        'download_selist_only',
        'vlan_id',
        'snat_ip',
        'vip_intf_ip',
        'vip_intf_list',
        'floating_intf_ip',
        'is_portchannel',
        'scalein_in_progress',
        'admin_down_requested',
        'at_curr_ver',
        'version',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'se_uuid': se_uuid_schema,
        'is_primary': is_primary_schema,
        'is_standby': is_standby_schema,
        'is_connected': is_connected_schema,
        'delete_in_progress': delete_in_progress_schema,
        'vcpus': vcpus_schema,
        'memory': memory_schema,
        'vip_intf_mac': vip_intf_mac_schema,
        'vip_subnet_mask': vip_subnet_mask_schema,
        'vnic': vnic_schema,
        'pending_download': pending_download_schema,
        'sec_idx': sec_idx_schema,
        'download_selist_only': download_selist_only_schema,
        'vlan_id': vlan_id_schema,
        'snat_ip': snat_ip_schema,
        'vip_intf_ip': vip_intf_ip_schema,
        'vip_intf_list': vip_intf_list_schema,
        'floating_intf_ip': floating_intf_ip_schema,
        'is_portchannel': is_portchannel_schema,
        'scalein_in_progress': scalein_in_progress_schema,
        'admin_down_requested': admin_down_requested_schema,
        'at_curr_ver': at_curr_ver_schema,
        'version': version_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'vnic': getattr(VsSeVnic, 'field_references', {}),
        'vip_intf_ip': getattr(IpAddr, 'field_references', {}),
        'vip_intf_list': getattr(SeVipInterfaceList, 'field_references', {}),
        'snat_ip': getattr(IpAddr, 'field_references', {}),
        'se_uuid': 'serviceengine',
        'floating_intf_ip': getattr(IpAddr, 'field_references', {}),
    }

    unique_keys = {
        'vnic': getattr(VsSeVnic, 'unique_keys', {}),
        'vip_intf_ip': getattr(IpAddr, 'unique_keys', {}),
        'snat_ip': getattr(IpAddr, 'unique_keys', {}),
        'floating_intf_ip': getattr(IpAddr, 'unique_keys', {}),
        'vip_intf_list': getattr(SeVipInterfaceList, 'unique_keys', {}),
    }



class VirtualService(AviResource):
    resource_name = "virtualservice"
    # all schemas
    name_schema = properties.Schema(
        properties.Schema.STRING,
        _("Name for the Virtual Service."),
        required=True,
        update_allowed=True,
    )
    fqdn_schema = properties.Schema(
        properties.Schema.STRING,
        _("DNS resolvable, fully qualified domain name of the virtualservice. Only one of 'fqdn' and 'dns_info' configuration is allowed."),
        required=False,
        update_allowed=True,
    )
    ip_address_schema = properties.Schema(
        properties.Schema.MAP,
        _("IP Address of the Virtual Service."),
        schema=IpAddr.properties_schema,
        required=False,
        update_allowed=True,
    )
    enabled_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _("Enable or disable the Virtual Service."),
        required=False,
        update_allowed=True,
    )
    services_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=Service.properties_schema,
        required=True,
        update_allowed=False,
    )
    services_schema = properties.Schema(
        properties.Schema.LIST,
        _("List of Services defined for this Virtual Service."),
        schema=services_item_schema,
        required=False,
        update_allowed=True,
    )
    application_profile_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("Enable application layer specific features for the Virtual Service. You can either provide UUID or provide a name with the prefix 'get_avi_uuid_by_name:', e.g., 'get_avi_uuid_by_name:my_obj_name'."),
        required=False,
        update_allowed=True,
    )
    network_profile_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("Determines network settings such as protocol, TCP or UDP, and related options for the protocol. You can either provide UUID or provide a name with the prefix 'get_avi_uuid_by_name:', e.g., 'get_avi_uuid_by_name:my_obj_name'."),
        required=False,
        update_allowed=True,
    )
    server_network_profile_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("Determines the network settings profile for the server side of TCP proxied connections.  Leave blank to use the same settings as the client to VS side of the connection. You can either provide UUID or provide a name with the prefix 'get_avi_uuid_by_name:', e.g., 'get_avi_uuid_by_name:my_obj_name'."),
        required=False,
        update_allowed=True,
    )
    pool_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("The pool is an object that contains destination servers and related attributes such as load-balancing and persistence. You can either provide UUID or provide a name with the prefix 'get_avi_uuid_by_name:', e.g., 'get_avi_uuid_by_name:my_obj_name'."),
        required=False,
        update_allowed=True,
    )
    se_group_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("The Service Engine Group to use for this Virtual Service. Moving to a new SE Group is disruptive to existing connections for this VS. You can either provide UUID or provide a name with the prefix 'get_avi_uuid_by_name:', e.g., 'get_avi_uuid_by_name:my_obj_name'."),
        required=False,
        update_allowed=True,
    )
    network_security_policy_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("Network security policies for the Virtual Service. You can either provide UUID or provide a name with the prefix 'get_avi_uuid_by_name:', e.g., 'get_avi_uuid_by_name:my_obj_name'."),
        required=False,
        update_allowed=True,
    )
    http_policies_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=HTTPPolicies.properties_schema,
        required=True,
        update_allowed=False,
    )
    http_policies_schema = properties.Schema(
        properties.Schema.LIST,
        _("HTTP Policies applied on the data traffic of the Virtual Service"),
        schema=http_policies_item_schema,
        required=False,
        update_allowed=True,
    )
    ssl_key_and_certificate_uuids_item_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=False,
    )
    ssl_key_and_certificate_uuids_schema = properties.Schema(
        properties.Schema.LIST,
        _("Select or create one or two certificates, EC and/or RSA, that will be presented to SSL/TLS terminated connections. You can either provide UUID or provide a name with the prefix 'get_avi_uuid_by_name:', e.g., 'get_avi_uuid_by_name:my_obj_name'."),
        schema=ssl_key_and_certificate_uuids_item_schema,
        required=False,
        update_allowed=True,
    )
    ssl_profile_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("Determines the set of SSL versions and ciphers to accept for SSL/TLS terminated connections. You can either provide UUID or provide a name with the prefix 'get_avi_uuid_by_name:', e.g., 'get_avi_uuid_by_name:my_obj_name'."),
        required=False,
        update_allowed=True,
    )
    performance_limits_schema = properties.Schema(
        properties.Schema.MAP,
        _("Optional settings that determine performance limits like max connections or bandwdith etc."),
        schema=PerformanceLimits.properties_schema,
        required=False,
        update_allowed=True,
    )
    analytics_policy_schema = properties.Schema(
        properties.Schema.MAP,
        _("Determines analytics settings for the application."),
        schema=AnalyticsPolicy.properties_schema,
        required=False,
        update_allowed=True,
    )
    network_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("Manually override the network on which the Virtual Service is placed. You can either provide UUID or provide a name with the prefix 'get_avi_uuid_by_name:', e.g., 'get_avi_uuid_by_name:my_obj_name'."),
        required=False,
        update_allowed=True,
    )
    vrf_context_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("Virtual Routing Context that the Virtual Service is bound to. This is used to provide the isolation of the set of networks the application is attached to. You can either provide UUID or provide a name with the prefix 'get_avi_uuid_by_name:', e.g., 'get_avi_uuid_by_name:my_obj_name'."),
        required=False,
        update_allowed=True,
    )
    enable_autogw_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _("Response traffic to clients will be sent back to the source MAC address of the connection, rather than statically sent to a default gateway."),
        required=False,
        update_allowed=True,
    )
    port_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("(internal-use) Network port assigned to the Virtual Service IP address."),
        required=False,
        update_allowed=True,
    )
    subnet_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("It represents subnet for the Virtual Service IP address allocation when auto_allocate_ip is True.It is only applicable in OpenStack or AWS cloud. This field is required if auto_allocate_ip is True."),
        required=False,
        update_allowed=True,
    )
    analytics_profile_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("Specifies settings related to analytics. You can either provide UUID or provide a name with the prefix 'get_avi_uuid_by_name:', e.g., 'get_avi_uuid_by_name:my_obj_name'."),
        required=False,
        update_allowed=True,
    )
    discovered_network_uuid_item_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=False,
    )
    discovered_network_uuid_schema = properties.Schema(
        properties.Schema.LIST,
        _("(internal-use) Discovered networks providing reachability for client facing Virtual Service IP. This field is deprecated. You can either provide UUID or provide a name with the prefix 'get_avi_uuid_by_name:', e.g., 'get_avi_uuid_by_name:my_obj_name'."),
        schema=discovered_network_uuid_item_schema,
        required=False,
        update_allowed=True,
    )
    discovered_subnet_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=IpAddrPrefix.properties_schema,
        required=True,
        update_allowed=False,
    )
    discovered_subnet_schema = properties.Schema(
        properties.Schema.LIST,
        _("(internal-use) Discovered subnets providing reachability for client facing Virtual Service IP. This field is deprecated."),
        schema=discovered_subnet_item_schema,
        required=False,
        update_allowed=True,
    )
    host_name_xlate_schema = properties.Schema(
        properties.Schema.STRING,
        _("Translate the host name sent to the servers to this value.  Translate the host name sent from servers back to the value used by the client."),
        required=False,
        update_allowed=True,
    )
    subnet_schema = properties.Schema(
        properties.Schema.MAP,
        _("Subnet providing reachability for client facing Virtual Service IP."),
        schema=IpAddrPrefix.properties_schema,
        required=False,
        update_allowed=True,
    )
    discovered_networks_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=DiscoveredNetwork.properties_schema,
        required=True,
        update_allowed=False,
    )
    discovered_networks_schema = properties.Schema(
        properties.Schema.LIST,
        _("(internal-use) Discovered networks providing reachability for client facing Virtual Service IP. This field is used internally by Avi, not editable by the user."),
        schema=discovered_networks_item_schema,
        required=False,
        update_allowed=True,
    )
    vs_datascripts_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=VSDataScripts.properties_schema,
        required=True,
        update_allowed=False,
    )
    vs_datascripts_schema = properties.Schema(
        properties.Schema.LIST,
        _("Datascripts applied on the data traffic of the Virtual Service"),
        schema=vs_datascripts_item_schema,
        required=False,
        update_allowed=True,
    )
    client_auth_schema = properties.Schema(
        properties.Schema.MAP,
        _("HTTP authentication configuration for protected resources."),
        schema=HTTPClientAuthenticationParams.properties_schema,
        required=False,
        update_allowed=True,
    )
    weight_schema = properties.Schema(
        properties.Schema.NUMBER,
        _("The Quality of Service weight to assign to traffic transmitted from this Virtual Service.  A higher weight will prioritize traffic versus other Virtual Services sharing the same Service Engines."),
        required=False,
        update_allowed=True,
    )
    delay_fairness_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _("Select the algorithm for QoS fairness.  This determines how multiple Virtual Services sharing the same Service Engines will prioritize traffic over a congested network."),
        required=False,
        update_allowed=True,
    )
    max_cps_per_client_schema = properties.Schema(
        properties.Schema.NUMBER,
        _("Maximum connections per second per client IP."),
        required=False,
        update_allowed=True,
    )
    limit_doser_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _("Limit potential DoS attackers who exceed max_cps_per_client significantly to a fraction of max_cps_per_client for a while."),
        required=False,
        update_allowed=True,
    )
    type_schema = properties.Schema(
        properties.Schema.STRING,
        _("Specify if this is a normal Virtual Service, or if it is the parent or child of an SNI-enabled virtual hosted Virtual Service."),
        required=False,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['VS_TYPE_VH_PARENT', 'VS_TYPE_VH_CHILD', 'VS_TYPE_NORMAL']),
        ],
    )
    vh_parent_vs_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("Specifies the Virtual Service acting as Virtual Hosting (SNI) parent."),
        required=False,
        update_allowed=True,
    )
    vh_domain_name_item_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=False,
    )
    vh_domain_name_schema = properties.Schema(
        properties.Schema.LIST,
        _("The exact name requested from the client's SNI-enabled TLS hello domain name field. If this is a match, the parent VS will forward the connection to this child VS."),
        schema=vh_domain_name_item_schema,
        required=False,
        update_allowed=True,
    )
    availability_zone_schema = properties.Schema(
        properties.Schema.STRING,
        _("Availability-zone to place the Virtual Service."),
        required=False,
        update_allowed=True,
    )
    auto_allocate_ip_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _("Auto-allocate VIP from the provided subnet."),
        required=False,
        update_allowed=True,
    )
    floating_ip_schema = properties.Schema(
        properties.Schema.MAP,
        _("Floating IP to associate with this Virtual Service."),
        schema=IpAddr.properties_schema,
        required=False,
        update_allowed=True,
    )
    auto_allocate_floating_ip_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _("Auto-allocate floating/elastic IP from the Cloud infrastructure."),
        required=False,
        update_allowed=True,
    )
    floating_subnet_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("If auto_allocate_floating_ip is True and more than one floating-ip subnets exist, then the subnet for the floating IP address allocation. This field is applicable only if the VirtualService belongs to an OpenStack or AWS cloud. In OpenStack or AWS cloud it is required when auto_allocate_floating_ip is selected."),
        required=False,
        update_allowed=True,
    )
    cloud_type_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=False,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['CLOUD_VCENTER', 'CLOUD_DOCKER_UCP', 'CLOUD_APIC', 'CLOUD_OPENSTACK', 'CLOUD_MESOS', 'CLOUD_RANCHER', 'CLOUD_VCA', 'CLOUD_LINUXSERVER', 'CLOUD_OSHIFT_K8S', 'CLOUD_AWS', 'CLOUD_NONE']),
        ],
    )
    avi_allocated_vip_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _("(internal-use) VIP allocated by Avi in the Cloud infrastructure."),
        required=False,
        update_allowed=True,
    )
    avi_allocated_fip_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _("(internal-use) FIP allocated by Avi in the Cloud infrastructure."),
        required=False,
        update_allowed=True,
    )
    connections_rate_limit_schema = properties.Schema(
        properties.Schema.MAP,
        _("Rate limit the incoming connections to this virtual service"),
        schema=RateProfile.properties_schema,
        required=False,
        update_allowed=True,
    )
    requests_rate_limit_schema = properties.Schema(
        properties.Schema.MAP,
        _("Rate limit the incoming requests to this virtual service"),
        schema=RateProfile.properties_schema,
        required=False,
        update_allowed=True,
    )
    use_bridge_ip_as_vip_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _("Use Bridge IP as VIP on each Host in Mesos deployments"),
        required=False,
        update_allowed=True,
    )
    flow_dist_schema = properties.Schema(
        properties.Schema.STRING,
        _("Criteria for flow distribution among SEs."),
        required=False,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['CONSISTENT_HASH_SOURCE_IP_ADDRESS_AND_PORT', 'LOAD_AWARE', 'CONSISTENT_HASH_SOURCE_IP_ADDRESS']),
        ],
    )
    ign_pool_net_reach_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _("Ignore Pool servers network reachability constraints for Virtual Service placement."),
        required=False,
        update_allowed=True,
    )
    ssl_sess_cache_avg_size_schema = properties.Schema(
        properties.Schema.NUMBER,
        _("Expected number of SSL session cache entries (may be exceeded)."),
        required=False,
        update_allowed=True,
    )
    pool_group_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("The pool group is an object that contains pools. You can either provide UUID or provide a name with the prefix 'get_avi_uuid_by_name:', e.g., 'get_avi_uuid_by_name:my_obj_name'."),
        required=False,
        update_allowed=True,
    )
    remove_listening_port_on_vs_down_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _("Remove listening port if VirtualService is down"),
        required=False,
        update_allowed=True,
    )
    description_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=False,
        update_allowed=True,
    )
    east_west_placement_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _("Force placement on all SE's in service group (Mesos mode only)"),
        required=False,
        update_allowed=True,
    )
    scaleout_ecmp_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _("Disable re-distribution of flows across service engines for a virtual service. Enable if the network itself performs flow hashing with ECMP in environments such as GCP"),
        required=False,
        update_allowed=True,
    )
    microservice_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("Microservice representing the virtual service You can either provide UUID or provide a name with the prefix 'get_avi_uuid_by_name:', e.g., 'get_avi_uuid_by_name:my_obj_name'."),
        required=False,
        update_allowed=True,
    )
    service_pool_select_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=ServicePoolSelector.properties_schema,
        required=True,
        update_allowed=False,
    )
    service_pool_select_schema = properties.Schema(
        properties.Schema.LIST,
        _("Select pool based on destination port"),
        schema=service_pool_select_item_schema,
        required=False,
        update_allowed=True,
    )
    created_by_schema = properties.Schema(
        properties.Schema.STRING,
        _("Creator name"),
        required=False,
        update_allowed=True,
    )
    cloud_config_cksum_schema = properties.Schema(
        properties.Schema.STRING,
        _("Checksum of cloud configuration for VS. Internally set by cloud connector"),
        required=False,
        update_allowed=True,
    )
    enable_rhi_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _("Enable Route Health Injection using the BGP Config in the vrf context"),
        required=False,
        update_allowed=True,
    )
    snat_ip_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=IpAddr.properties_schema,
        required=True,
        update_allowed=False,
    )
    snat_ip_schema = properties.Schema(
        properties.Schema.LIST,
        _("NAT'ted floating source IP Address(es) for upstream connection to servers"),
        schema=snat_ip_item_schema,
        required=False,
        update_allowed=True,
    )
    active_standby_se_tag_schema = properties.Schema(
        properties.Schema.STRING,
        _("This configuration only applies if the VirtualService is in Legacy Active Standby HA mode and Load Distribution among Active Standby is enabled. This field is used to tag the VirtualService so that VirtualServices with the same tag will share the same Active ServiceEngine. VirtualServices with different tags will have different Active ServiceEngines. If one of the ServiceEngine's in the ServiceEngineGroup fails, all VirtualServices will end up using the same Active ServiceEngine. Redistribution of the VirtualServices can be either manual or automated when the failed ServiceEngine recovers. Redistribution is based on the auto redistribute property of the ServiceEngineGroup."),
        required=False,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['ACTIVE_STANDBY_SE_1', 'ACTIVE_STANDBY_SE_2']),
        ],
    )
    flow_label_type_schema = properties.Schema(
        properties.Schema.STRING,
        _("Criteria for flow labelling."),
        required=False,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['NO_LABEL', 'SERVICE_LABEL']),
        ],
    )
    enable_rhi_snat_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _("Enable Route Health Injection for Source NAT'ted floating IP Address using the BGP Config in the vrf context"),
        required=False,
        update_allowed=True,
    )
    static_dns_records_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=DnsRecord.properties_schema,
        required=True,
        update_allowed=False,
    )
    static_dns_records_schema = properties.Schema(
        properties.Schema.LIST,
        _("List of static DNS records applied to this Virtual Service. These are static entries and no health monitoring is performed against the IP addresses."),
        schema=static_dns_records_item_schema,
        required=False,
        update_allowed=True,
    )
    ipam_network_subnet_schema = properties.Schema(
        properties.Schema.MAP,
        _("Subnet and/or Network for allocating VirtualService IP by IPAM Provider module."),
        schema=IPNetworkSubnet.properties_schema,
        required=False,
        update_allowed=True,
    )
    dns_info_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=DnsInfo.properties_schema,
        required=True,
        update_allowed=False,
    )
    dns_info_schema = properties.Schema(
        properties.Schema.LIST,
        _("Service discovery specific data including fully qualified domain name, type and Time-To-Live of the DNS record. Note that only one of fqdn and dns_info setting is allowed."),
        schema=dns_info_item_schema,
        required=False,
        update_allowed=True,
    )
    service_metadata_schema = properties.Schema(
        properties.Schema.STRING,
        _("Metadata pertaining to the Service provided by this virtual service. In Openshift/Kubernetes environments, egress pod info is stored. Any user input to this field will be overwritten by Avi Vantage."),
        required=False,
        update_allowed=True,
    )
    content_rewrite_schema = properties.Schema(
        properties.Schema.MAP,
        _("Profile used to match and rewrite strings in request and/or response body."),
        schema=ContentRewriteProfile.properties_schema,
        required=False,
        update_allowed=True,
    )
    sideband_profile_schema = properties.Schema(
        properties.Schema.MAP,
        _("Sideband configuration to be used for this virtualservice.It can be used for sending traffic to sideband VIPs for external inspection etc."),
        schema=SidebandProfile.properties_schema,
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'name',
        'fqdn',
        'ip_address',
        'enabled',
        'services',
        'application_profile_uuid',
        'network_profile_uuid',
        'server_network_profile_uuid',
        'pool_uuid',
        'se_group_uuid',
        'network_security_policy_uuid',
        'http_policies',
        'ssl_key_and_certificate_uuids',
        'ssl_profile_uuid',
        'performance_limits',
        'analytics_policy',
        'network_uuid',
        'vrf_context_uuid',
        'enable_autogw',
        'port_uuid',
        'subnet_uuid',
        'analytics_profile_uuid',
        'discovered_network_uuid',
        'discovered_subnet',
        'host_name_xlate',
        'subnet',
        'discovered_networks',
        'vs_datascripts',
        'client_auth',
        'weight',
        'delay_fairness',
        'max_cps_per_client',
        'limit_doser',
        'type',
        'vh_parent_vs_uuid',
        'vh_domain_name',
        'availability_zone',
        'auto_allocate_ip',
        'floating_ip',
        'auto_allocate_floating_ip',
        'floating_subnet_uuid',
        'cloud_type',
        'avi_allocated_vip',
        'avi_allocated_fip',
        'connections_rate_limit',
        'requests_rate_limit',
        'use_bridge_ip_as_vip',
        'flow_dist',
        'ign_pool_net_reach',
        'ssl_sess_cache_avg_size',
        'pool_group_uuid',
        'remove_listening_port_on_vs_down',
        'description',
        'east_west_placement',
        'scaleout_ecmp',
        'microservice_uuid',
        'service_pool_select',
        'created_by',
        'cloud_config_cksum',
        'enable_rhi',
        'snat_ip',
        'active_standby_se_tag',
        'flow_label_type',
        'enable_rhi_snat',
        'static_dns_records',
        'ipam_network_subnet',
        'dns_info',
        'service_metadata',
        'content_rewrite',
        'sideband_profile',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'name': name_schema,
        'fqdn': fqdn_schema,
        'ip_address': ip_address_schema,
        'enabled': enabled_schema,
        'services': services_schema,
        'application_profile_uuid': application_profile_uuid_schema,
        'network_profile_uuid': network_profile_uuid_schema,
        'server_network_profile_uuid': server_network_profile_uuid_schema,
        'pool_uuid': pool_uuid_schema,
        'se_group_uuid': se_group_uuid_schema,
        'network_security_policy_uuid': network_security_policy_uuid_schema,
        'http_policies': http_policies_schema,
        'ssl_key_and_certificate_uuids': ssl_key_and_certificate_uuids_schema,
        'ssl_profile_uuid': ssl_profile_uuid_schema,
        'performance_limits': performance_limits_schema,
        'analytics_policy': analytics_policy_schema,
        'network_uuid': network_uuid_schema,
        'vrf_context_uuid': vrf_context_uuid_schema,
        'enable_autogw': enable_autogw_schema,
        'port_uuid': port_uuid_schema,
        'subnet_uuid': subnet_uuid_schema,
        'analytics_profile_uuid': analytics_profile_uuid_schema,
        'discovered_network_uuid': discovered_network_uuid_schema,
        'discovered_subnet': discovered_subnet_schema,
        'host_name_xlate': host_name_xlate_schema,
        'subnet': subnet_schema,
        'discovered_networks': discovered_networks_schema,
        'vs_datascripts': vs_datascripts_schema,
        'client_auth': client_auth_schema,
        'weight': weight_schema,
        'delay_fairness': delay_fairness_schema,
        'max_cps_per_client': max_cps_per_client_schema,
        'limit_doser': limit_doser_schema,
        'type': type_schema,
        'vh_parent_vs_uuid': vh_parent_vs_uuid_schema,
        'vh_domain_name': vh_domain_name_schema,
        'availability_zone': availability_zone_schema,
        'auto_allocate_ip': auto_allocate_ip_schema,
        'floating_ip': floating_ip_schema,
        'auto_allocate_floating_ip': auto_allocate_floating_ip_schema,
        'floating_subnet_uuid': floating_subnet_uuid_schema,
        'cloud_type': cloud_type_schema,
        'avi_allocated_vip': avi_allocated_vip_schema,
        'avi_allocated_fip': avi_allocated_fip_schema,
        'connections_rate_limit': connections_rate_limit_schema,
        'requests_rate_limit': requests_rate_limit_schema,
        'use_bridge_ip_as_vip': use_bridge_ip_as_vip_schema,
        'flow_dist': flow_dist_schema,
        'ign_pool_net_reach': ign_pool_net_reach_schema,
        'ssl_sess_cache_avg_size': ssl_sess_cache_avg_size_schema,
        'pool_group_uuid': pool_group_uuid_schema,
        'remove_listening_port_on_vs_down': remove_listening_port_on_vs_down_schema,
        'description': description_schema,
        'east_west_placement': east_west_placement_schema,
        'scaleout_ecmp': scaleout_ecmp_schema,
        'microservice_uuid': microservice_uuid_schema,
        'service_pool_select': service_pool_select_schema,
        'created_by': created_by_schema,
        'cloud_config_cksum': cloud_config_cksum_schema,
        'enable_rhi': enable_rhi_schema,
        'snat_ip': snat_ip_schema,
        'active_standby_se_tag': active_standby_se_tag_schema,
        'flow_label_type': flow_label_type_schema,
        'enable_rhi_snat': enable_rhi_snat_schema,
        'static_dns_records': static_dns_records_schema,
        'ipam_network_subnet': ipam_network_subnet_schema,
        'dns_info': dns_info_schema,
        'service_metadata': service_metadata_schema,
        'content_rewrite': content_rewrite_schema,
        'sideband_profile': sideband_profile_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'client_auth': getattr(HTTPClientAuthenticationParams, 'field_references', {}),
        'network_uuid': 'network',
        'network_profile_uuid': 'networkprofile',
        'dns_info': getattr(DnsInfo, 'field_references', {}),
        'vs_datascripts': getattr(VSDataScripts, 'field_references', {}),
        'content_rewrite': getattr(ContentRewriteProfile, 'field_references', {}),
        'snat_ip': getattr(IpAddr, 'field_references', {}),
        'discovered_network_uuid': 'network',
        'sideband_profile': getattr(SidebandProfile, 'field_references', {}),
        'vrf_context_uuid': 'vrfcontext',
        'subnet': getattr(IpAddrPrefix, 'field_references', {}),
        'se_group_uuid': 'serviceenginegroup',
        'requests_rate_limit': getattr(RateProfile, 'field_references', {}),
        'application_profile_uuid': 'applicationprofile',
        'pool_group_uuid': 'poolgroup',
        'analytics_profile_uuid': 'analyticsprofile',
        'performance_limits': getattr(PerformanceLimits, 'field_references', {}),
        'http_policies': getattr(HTTPPolicies, 'field_references', {}),
        'server_network_profile_uuid': 'networkprofile',
        'floating_ip': getattr(IpAddr, 'field_references', {}),
        'microservice_uuid': 'microservice',
        'services': getattr(Service, 'field_references', {}),
        'connections_rate_limit': getattr(RateProfile, 'field_references', {}),
        'ip_address': getattr(IpAddr, 'field_references', {}),
        'service_pool_select': getattr(ServicePoolSelector, 'field_references', {}),
        'network_security_policy_uuid': 'networksecuritypolicy',
        'discovered_networks': getattr(DiscoveredNetwork, 'field_references', {}),
        'ssl_key_and_certificate_uuids': 'sslkeyandcertificate',
        'ipam_network_subnet': getattr(IPNetworkSubnet, 'field_references', {}),
        'discovered_subnet': getattr(IpAddrPrefix, 'field_references', {}),
        'ssl_profile_uuid': 'sslprofile',
        'static_dns_records': getattr(DnsRecord, 'field_references', {}),
        'analytics_policy': getattr(AnalyticsPolicy, 'field_references', {}),
        'pool_uuid': 'pool',
    }

    unique_keys = {
        'requests_rate_limit': getattr(RateProfile, 'unique_keys', {}),
        'subnet': getattr(IpAddrPrefix, 'unique_keys', {}),
        'static_dns_records': getattr(DnsRecord, 'unique_keys', {}),
        'service_pool_select': getattr(ServicePoolSelector, 'unique_keys', {}),
        'performance_limits': getattr(PerformanceLimits, 'unique_keys', {}),
        'http_policies': getattr(HTTPPolicies, 'unique_keys', {}),
        'vs_datascripts': getattr(VSDataScripts, 'unique_keys', {}),
        'discovered_networks': getattr(DiscoveredNetwork, 'unique_keys', {}),
        'dns_info': getattr(DnsInfo, 'unique_keys', {}),
        'floating_ip': getattr(IpAddr, 'unique_keys', {}),
        'discovered_subnet': getattr(IpAddrPrefix, 'unique_keys', {}),
        'client_auth': getattr(HTTPClientAuthenticationParams, 'unique_keys', {}),
        'snat_ip': getattr(IpAddr, 'unique_keys', {}),
        'analytics_policy': getattr(AnalyticsPolicy, 'unique_keys', {}),
        'ipam_network_subnet': getattr(IPNetworkSubnet, 'unique_keys', {}),
        'services': getattr(Service, 'unique_keys', {}),
        'connections_rate_limit': getattr(RateProfile, 'unique_keys', {}),
        'ip_address': getattr(IpAddr, 'unique_keys', {}),
        'sideband_profile': getattr(SidebandProfile, 'unique_keys', {}),
        'content_rewrite': getattr(ContentRewriteProfile, 'unique_keys', {}),
    }



def resource_mapping():
    return {
        'Avi::LBaaS::VirtualService': VirtualService,
    }

