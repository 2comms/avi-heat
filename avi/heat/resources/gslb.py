# GENERATED FILE - DO NOT EDIT THIS FILE UNLESS YOU ARE A WIZZARD
#pylint:  skip-file
from heat.engine import properties
from heat.engine import constraints
from heat.engine import attributes
from heat.common.i18n import _
from avi.heat.avi_resource import AviResource
from avi.heat.avi_resource import AviNestedResource
from options import *

from options import *
from health_monitor import *


class GSLBVirtualServiceDownResponse(object):
    # all schemas
    type_schema = properties.Schema(
        properties.Schema.STRING,
        _("Response from DNS service towards the client when the GSLB Virtual Service is DOWN"),
        required=True,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['GSLB_VIRTUALSERVICE_DOWN_RESPONSE_ALL_RECORDS', 'GSLB_VIRTUALSERVICE_DOWN_RESPONSE_FALLBACK_IP', 'GSLB_VIRTUALSERVICE_DOWN_RESPONSE_EMPTY', 'GSLB_VIRTUALSERVICE_DOWN_RESPONSE_NONE']),
        ],
    )
    fallback_ip_schema = properties.Schema(
        properties.Schema.MAP,
        _("Fallback IP address to use in response to the client query when the GSLB Virtual Service is DOWN"),
        schema=IpAddr.properties_schema,
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'type',
        'fallback_ip',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'type': type_schema,
        'fallback_ip': fallback_ip_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'fallback_ip': getattr(IpAddr, 'field_references', {}),
    }



class DNSConfig(object):
    # all schemas
    domain_name_schema = properties.Schema(
        properties.Schema.STRING,
        _("GSLB domain used for Globalservice FQDN match and placement"),
        required=True,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'domain_name',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'domain_name': domain_name_schema,
    }




class SiteControllerCluster(object):
    # all schemas
    cluster_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("UUID of the 'Cluster' object of the Controller Cluster in this site."),
        required=True,
        update_allowed=True,
    )
    name_schema = properties.Schema(
        properties.Schema.STRING,
        _("Name for the Site Controller Cluster."),
        required=True,
        update_allowed=True,
    )
    address_schema = properties.Schema(
        properties.Schema.STRING,
        _("IP Address or a DNS resolvable, fully qualified domain name of the Site Controller Cluster."),
        required=False,
        update_allowed=True,
    )
    ip_addresses_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=IpAddr.properties_schema,
        required=True,
        update_allowed=False,
    )
    ip_addresses_schema = properties.Schema(
        properties.Schema.LIST,
        _("IP Address(es) of the Site Controller Cluster. For a 3-node cluster, either the cluster vIP is provided, or the list of controller IPs in the cluster are provided."),
        schema=ip_addresses_item_schema,
        required=False,
        update_allowed=True,
    )
    port_schema = properties.Schema(
        properties.Schema.NUMBER,
        _("The Site Controller Cluster's REST API port number."),
        required=False,
        update_allowed=True,
    )
    username_schema = properties.Schema(
        properties.Schema.STRING,
        _("The username used when authenticating with the Site Controller Cluster. "),
        required=False,
        update_allowed=True,
    )
    password_schema = properties.Schema(
        properties.Schema.STRING,
        _("The password used when authenticating with the Site Controller Cluster."),
        required=False,
        update_allowed=True,
    )
    dns_vs_uuids_item_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=False,
    )
    dns_vs_uuids_schema = properties.Schema(
        properties.Schema.LIST,
        _("The list of DNS-VSes on which the GSes shall be placed.The site has to be a PRIMARY member"),
        schema=dns_vs_uuids_item_schema,
        required=False,
        update_allowed=True,
    )
    member_type_schema = properties.Schema(
        properties.Schema.STRING,
        _("The site's member type: A leader is set to PRIMARY while allfollowers are set to SECONDARY. "),
        required=False,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['SITE_PRIMARY_MEMBER', 'SITE_SECONDARY_MEMBER']),
        ],
    )

    # properties list
    PROPERTIES = (
        'cluster_uuid',
        'name',
        'address',
        'ip_addresses',
        'port',
        'username',
        'password',
        'dns_vs_uuids',
        'member_type',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'cluster_uuid': cluster_uuid_schema,
        'name': name_schema,
        'address': address_schema,
        'ip_addresses': ip_addresses_schema,
        'port': port_schema,
        'username': username_schema,
        'password': password_schema,
        'dns_vs_uuids': dns_vs_uuids_schema,
        'member_type': member_type_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'ip_addresses': getattr(IpAddr, 'field_references', {}),
    }



class GlobalLB(AviResource):
    resource_name = "globallb"
    # all schemas
    name_schema = properties.Schema(
        properties.Schema.STRING,
        _("Name for the GlobalLB."),
        required=True,
        update_allowed=True,
    )
    dns_configs_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=DNSConfig.properties_schema,
        required=True,
        update_allowed=False,
    )
    dns_configs_schema = properties.Schema(
        properties.Schema.LIST,
        _("Dns configuration for this GSLB. GlobalService FQDNmust be a member of this rule-set "),
        schema=dns_configs_item_schema,
        required=False,
        update_allowed=True,
    )
    site_controller_clusters_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=SiteControllerCluster.properties_schema,
        required=True,
        update_allowed=False,
    )
    site_controller_clusters_schema = properties.Schema(
        properties.Schema.LIST,
        _("Select Site Controller Cluster belonging to this GSLB"),
        schema=site_controller_clusters_item_schema,
        required=False,
        update_allowed=True,
    )
    owner_controller_cluster_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("Mark this Site Controller Cluster as owner of GSLB configuration. This is the one among the site-controller-sites"),
        required=True,
        update_allowed=True,
    )
    send_interval_schema = properties.Schema(
        properties.Schema.NUMBER,
        _("Frequency with which group members communicate."),
        required=False,
        update_allowed=True,
    )
    clear_on_max_retries_schema = properties.Schema(
        properties.Schema.NUMBER,
        _("Max retries after which the remote site is treatedas a fresh start. In fresh start all the configsare downloaded."),
        required=False,
        update_allowed=True,
    )
    view_id_schema = properties.Schema(
        properties.Schema.NUMBER,
        _("The view-id is used in maintenance mode to differentiate partitioned groups while they havethe same globallb namespace. Each partitioned groupwill be able to operate independently by using theview-id."),
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'name',
        'dns_configs',
        'site_controller_clusters',
        'owner_controller_cluster_uuid',
        'send_interval',
        'clear_on_max_retries',
        'view_id',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'name': name_schema,
        'dns_configs': dns_configs_schema,
        'site_controller_clusters': site_controller_clusters_schema,
        'owner_controller_cluster_uuid': owner_controller_cluster_uuid_schema,
        'send_interval': send_interval_schema,
        'clear_on_max_retries': clear_on_max_retries_schema,
        'view_id': view_id_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'site_controller_clusters': getattr(SiteControllerCluster, 'field_references', {}),
        'dns_configs': getattr(DNSConfig, 'field_references', {}),
    }



class GSMember(object):
    # all schemas
    controller_cluster_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("The Cluster UUID of the Site Controller Cluster"),
        required=False,
        update_allowed=True,
    )
    vs_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("Select local virtual service in the specified controller cluster belonging to this GlobalService"),
        required=False,
        update_allowed=True,
    )
    ip_schema = properties.Schema(
        properties.Schema.MAP,
        _("IP Address of the Local Virtual Service."),
        schema=IpAddr.properties_schema,
        required=True,
        update_allowed=True,
    )
    public_ip_schema = properties.Schema(
        properties.Schema.MAP,
        _("Public IP Address of the Local Virtual Service."),
        schema=IpAddr.properties_schema,
        required=False,
        update_allowed=True,
    )
    health_monitor_public_only_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _("Health Monitor only the Public IP Address of the Local Virtual Service. Use this when there is no VPN between G-DNS and vIPs"),
        required=False,
        update_allowed=True,
    )
    ratio_schema = properties.Schema(
        properties.Schema.NUMBER,
        _("Overrides the default ratio of 1.  Reduces the percentage the LB algorithm would pick the server in relation to its peers.  Range is 1-20."),
        required=False,
        update_allowed=True,
    )
    enabled_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _("Enable or Disable member to decide if this address should be provided in DNS responses"),
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'controller_cluster_uuid',
        'vs_uuid',
        'ip',
        'public_ip',
        'health_monitor_public_only',
        'ratio',
        'enabled',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'controller_cluster_uuid': controller_cluster_uuid_schema,
        'vs_uuid': vs_uuid_schema,
        'ip': ip_schema,
        'public_ip': public_ip_schema,
        'health_monitor_public_only': health_monitor_public_only_schema,
        'ratio': ratio_schema,
        'enabled': enabled_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'public_ip': getattr(IpAddr, 'field_references', {}),
        'ip': getattr(IpAddr, 'field_references', {}),
    }



class GSMemberGroup(object):
    # all schemas
    name_schema = properties.Schema(
        properties.Schema.STRING,
        _("Name of the Global Service Member Group"),
        required=True,
        update_allowed=True,
    )
    priority_schema = properties.Schema(
        properties.Schema.NUMBER,
        _("Priority of this group of Members. If the priority of this is the highest in the group, DNS service picks up only this member for DNS responses."),
        required=False,
        update_allowed=True,
    )
    algorithm_schema = properties.Schema(
        properties.Schema.STRING,
        _("The load balancing algorithm will pick a local GS Member within the Global Service list of available Members."),
        required=True,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['GSLB_ALGORITHM_CONSISTENT_HASH', 'GSLB_ALGORITHM_ROUND_ROBIN']),
        ],
    )
    consistent_hash_mask_schema = properties.Schema(
        properties.Schema.NUMBER,
        _("Mask to be applied on client IP for consistent hash algorithm"),
        required=False,
        update_allowed=True,
    )
    members_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=GSMember.properties_schema,
        required=True,
        update_allowed=False,
    )
    members_schema = properties.Schema(
        properties.Schema.LIST,
        _("Select list of Virtual Services belonging to this GSLB"),
        schema=members_item_schema,
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'name',
        'priority',
        'algorithm',
        'consistent_hash_mask',
        'members',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'name': name_schema,
        'priority': priority_schema,
        'algorithm': algorithm_schema,
        'consistent_hash_mask': consistent_hash_mask_schema,
        'members': members_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'members': getattr(GSMember, 'field_references', {}),
    }



class GlobalService(AviResource):
    resource_name = "globalservice"
    # all schemas
    name_schema = properties.Schema(
        properties.Schema.STRING,
        _("Name for the Global Service."),
        required=True,
        update_allowed=True,
    )
    domain_names_item_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=False,
    )
    domain_names_schema = properties.Schema(
        properties.Schema.LIST,
        _("Fully qualified domain name of the Global Service."),
        schema=domain_names_item_schema,
        required=False,
        update_allowed=True,
    )
    groups_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=GSMemberGroup.properties_schema,
        required=True,
        update_allowed=False,
    )
    groups_schema = properties.Schema(
        properties.Schema.LIST,
        _("Select list of GS Member Groups belonging to this Global Service"),
        schema=groups_item_schema,
        required=False,
        update_allowed=True,
    )
    num_dns_ip_schema = properties.Schema(
        properties.Schema.NUMBER,
        _("Number of IP addresses of this Global Service to be returned by the DNS Service. Enter 0 to return all IP addresses"),
        required=False,
        update_allowed=True,
    )
    ttl_schema = properties.Schema(
        properties.Schema.NUMBER,
        _("TTL value for A records for this Global Service served by the DNS Service"),
        required=False,
        update_allowed=True,
    )
    down_response_schema = properties.Schema(
        properties.Schema.MAP,
        _("Response to the client query when the GSLB Virtual Service is DOWN"),
        schema=GSLBVirtualServiceDownResponse.properties_schema,
        required=False,
        update_allowed=True,
    )
    health_monitor_uuids_item_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=False,
    )
    health_monitor_uuids_schema = properties.Schema(
        properties.Schema.LIST,
        _("Verify VIP health by applying one or more health monitors.  Active monitors generate synthetic traffic from G-DNS Service Engine and to mark a VS up or down based on the response.  You can either provide UUID or provide a name with the prefix 'get_avi_uuid_for_name:', e.g., 'get_avi_uuid_for_name:my_obj_name'."),
        schema=health_monitor_uuids_item_schema,
        required=False,
        update_allowed=True,
    )
    site_persistence_type_schema = properties.Schema(
        properties.Schema.STRING,
        _("Persistence will ensure the same user sticks to the same vIP."),
        required=False,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['SITE_PERSISTENCE_NONE', 'SITE_PERSISTENCE_CLIENT_IP', 'SITE_PERSISTENCE_HTTP_COOKIE']),
        ],
    )
    site_persistence_profile_timeout_schema = properties.Schema(
        properties.Schema.NUMBER,
        _("Persistence will ensure the same user sticks to the same vIP for a desired duration of time."),
        required=False,
        update_allowed=True,
    )
    site_persistence_use_public_ip_schema = properties.Schema(
        properties.Schema.BOOLEAN,
        _("Indicate if Public IP Address of the Local Virtual Service should be used."),
        required=False,
        update_allowed=True,
    )
    description_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'name',
        'domain_names',
        'groups',
        'num_dns_ip',
        'ttl',
        'down_response',
        'health_monitor_uuids',
        'site_persistence_type',
        'site_persistence_profile_timeout',
        'site_persistence_use_public_ip',
        'description',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'name': name_schema,
        'domain_names': domain_names_schema,
        'groups': groups_schema,
        'num_dns_ip': num_dns_ip_schema,
        'ttl': ttl_schema,
        'down_response': down_response_schema,
        'health_monitor_uuids': health_monitor_uuids_schema,
        'site_persistence_type': site_persistence_type_schema,
        'site_persistence_profile_timeout': site_persistence_profile_timeout_schema,
        'site_persistence_use_public_ip': site_persistence_use_public_ip_schema,
        'description': description_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'health_monitor_uuids': 'globalhealthmonitor',
        'down_response': getattr(GSLBVirtualServiceDownResponse, 'field_references', {}),
        'groups': getattr(GSMemberGroup, 'field_references', {}),
    }



def resource_mapping():
    return {
        'Avi::LBaaS::GlobalService': GlobalService,
        'Avi::LBaaS::GlobalLB': GlobalLB,
    }

