# GENERATED FILE - DO NOT EDIT THIS FILE UNLESS YOU ARE A WIZZARD
#pylint:  skip-file
from heat.engine import properties
from heat.engine import constraints
from heat.engine import attributes
from heat.common.i18n import _
from avi.heat.avi_resource import AviResource
from avi.heat.avi_resource import AviNestedResource
from options import *

from common import *
from options import *


class ProtocolMatch(object):
    # all schemas
    match_criteria_schema = properties.Schema(
        properties.Schema.STRING,
        _("Criterion to use for protocol matching the HTTP request"),
        required=True,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['IS_NOT_IN', 'IS_IN']),
        ],
    )
    protocols_schema = properties.Schema(
        properties.Schema.STRING,
        _("HTTP or HTTPS protocol"),
        required=True,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['HTTP', 'HTTPS']),
        ],
    )

    # properties list
    PROPERTIES = (
        'match_criteria',
        'protocols',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'match_criteria': match_criteria_schema,
        'protocols': protocols_schema,
    }



class MicroServiceGroup(AviResource):
    resource_name = "microservicegroup"
    # all schemas
    name_schema = properties.Schema(
        properties.Schema.STRING,
        _("Name of the MicroService group"),
        required=True,
        update_allowed=True,
    )
    service_uuids_item_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=False,
    )
    service_uuids_schema = properties.Schema(
        properties.Schema.LIST,
        _("Configure MicroService(es) You can either provide UUID or provide a name with the prefix 'get_avi_uuid_for_name:', e.g., 'get_avi_uuid_for_name:my_obj_name'."),
        schema=service_uuids_item_schema,
        required=False,
        update_allowed=True,
    )
    created_by_schema = properties.Schema(
        properties.Schema.STRING,
        _("Creator name"),
        required=False,
        update_allowed=True,
    )
    description_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'name',
        'service_uuids',
        'created_by',
        'description',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'name': name_schema,
        'service_uuids': service_uuids_schema,
        'created_by': created_by_schema,
        'description': description_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'service_uuids': 'microservice',
    }



class MethodMatch(object):
    # all schemas
    match_criteria_schema = properties.Schema(
        properties.Schema.STRING,
        _("Criterion to use for HTTP method matching the method in the HTTP request"),
        required=True,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['IS_NOT_IN', 'IS_IN']),
        ],
    )
    methods_item_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=False,
        constraints=[
            constraints.AllowedValues(['HTTP_METHOD_HEAD', 'HTTP_METHOD_OPTIONS', 'HTTP_METHOD_PUT', 'HTTP_METHOD_DELETE', 'HTTP_METHOD_POST', 'HTTP_METHOD_GET', 'HTTP_METHOD_TRACE']),
        ],
    )
    methods_schema = properties.Schema(
        properties.Schema.LIST,
        _("Configure HTTP method(s)"),
        schema=methods_item_schema,
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'match_criteria',
        'methods',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'match_criteria': match_criteria_schema,
        'methods': methods_schema,
    }



class IpAddrMatch(object):
    # all schemas
    match_criteria_schema = properties.Schema(
        properties.Schema.STRING,
        _("Criterion to use for IP address matching the HTTP request"),
        required=True,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['IS_NOT_IN', 'IS_IN']),
        ],
    )
    addrs_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=IpAddr.properties_schema,
        required=True,
        update_allowed=False,
    )
    addrs_schema = properties.Schema(
        properties.Schema.LIST,
        _("IP address(es)"),
        schema=addrs_item_schema,
        required=False,
        update_allowed=True,
    )
    ranges_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=IpAddrRange.properties_schema,
        required=True,
        update_allowed=False,
    )
    ranges_schema = properties.Schema(
        properties.Schema.LIST,
        _("IP address range(s)"),
        schema=ranges_item_schema,
        required=False,
        update_allowed=True,
    )
    prefixes_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=IpAddrPrefix.properties_schema,
        required=True,
        update_allowed=False,
    )
    prefixes_schema = properties.Schema(
        properties.Schema.LIST,
        _("IP address prefix(es)"),
        schema=prefixes_item_schema,
        required=False,
        update_allowed=True,
    )
    group_uuids_item_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=False,
    )
    group_uuids_schema = properties.Schema(
        properties.Schema.LIST,
        _("UUID of IP address group(s) You can either provide UUID or provide a name with the prefix 'get_avi_uuid_for_name:', e.g., 'get_avi_uuid_for_name:my_obj_name'."),
        schema=group_uuids_item_schema,
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'match_criteria',
        'addrs',
        'ranges',
        'prefixes',
        'group_uuids',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'match_criteria': match_criteria_schema,
        'addrs': addrs_schema,
        'ranges': ranges_schema,
        'prefixes': prefixes_schema,
        'group_uuids': group_uuids_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'ranges': getattr(IpAddrRange, 'field_references', {}),
        'prefixes': getattr(IpAddrPrefix, 'field_references', {}),
        'addrs': getattr(IpAddr, 'field_references', {}),
        'group_uuids': 'ipaddrgroup',
    }

    unique_keys = {
        'ranges': getattr(IpAddrRange, 'unique_keys', {}),
        'prefixes': getattr(IpAddrPrefix, 'unique_keys', {}),
        'addrs': getattr(IpAddr, 'unique_keys', {}),
    }



class HdrMatch(object):
    # all schemas
    match_criteria_schema = properties.Schema(
        properties.Schema.STRING,
        _("Criterion to use for matching headers in the HTTP request"),
        required=True,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['HDR_ENDS_WITH', 'HDR_EQUALS', 'HDR_DOES_NOT_EXIST', 'HDR_EXISTS', 'HDR_DOES_NOT_END_WITH', 'HDR_DOES_NOT_EQUAL', 'HDR_DOES_NOT_CONTAIN', 'HDR_CONTAINS', 'HDR_BEGINS_WITH', 'HDR_DOES_NOT_BEGIN_WITH']),
        ],
    )
    hdr_schema = properties.Schema(
        properties.Schema.STRING,
        _("Name of the HTTP header whose value is to be matched"),
        required=True,
        update_allowed=True,
    )
    match_case_schema = properties.Schema(
        properties.Schema.STRING,
        _("Case sensitivity to use for the match"),
        required=False,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['SENSITIVE', 'INSENSITIVE']),
        ],
    )
    value_item_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=False,
    )
    value_schema = properties.Schema(
        properties.Schema.LIST,
        _("String values to match in the HTTP header"),
        schema=value_item_schema,
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'match_criteria',
        'hdr',
        'match_case',
        'value',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'match_criteria': match_criteria_schema,
        'hdr': hdr_schema,
        'match_case': match_case_schema,
        'value': value_schema,
    }



class HTTPStatusRange(object):
    # all schemas
    begin_schema = properties.Schema(
        properties.Schema.NUMBER,
        _("Starting HTTP response status code"),
        required=True,
        update_allowed=True,
    )
    end_schema = properties.Schema(
        properties.Schema.NUMBER,
        _("Ending HTTP response status code"),
        required=True,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'begin',
        'end',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'begin': begin_schema,
        'end': end_schema,
    }



class MicroServiceMatch(object):
    # all schemas
    match_criteria_schema = properties.Schema(
        properties.Schema.STRING,
        _("Criterion to use for Micro Service matching the HTTP request"),
        required=True,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['IS_NOT_IN', 'IS_IN']),
        ],
    )
    group_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("UUID of Micro Service group(s) You can either provide UUID or provide a name with the prefix 'get_avi_uuid_for_name:', e.g., 'get_avi_uuid_for_name:my_obj_name'."),
        required=True,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'match_criteria',
        'group_uuid',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'match_criteria': match_criteria_schema,
        'group_uuid': group_uuid_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'group_uuid': 'microservicegroup',
    }



class PortMatch(object):
    # all schemas
    match_criteria_schema = properties.Schema(
        properties.Schema.STRING,
        _("Criterion to use for port matching the HTTP request"),
        required=True,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['IS_NOT_IN', 'IS_IN']),
        ],
    )
    ports_item_schema = properties.Schema(
        properties.Schema.NUMBER,
        _(""),
        required=True,
        update_allowed=False,
    )
    ports_schema = properties.Schema(
        properties.Schema.LIST,
        _("TCP port(s) listening for HTTP/HTTPS"),
        schema=ports_item_schema,
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'match_criteria',
        'ports',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'match_criteria': match_criteria_schema,
        'ports': ports_schema,
    }



class CookieMatch(object):
    # all schemas
    match_criteria_schema = properties.Schema(
        properties.Schema.STRING,
        _("Criterion to use for matching the cookie in the HTTP request"),
        required=True,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['HDR_ENDS_WITH', 'HDR_EQUALS', 'HDR_DOES_NOT_EXIST', 'HDR_EXISTS', 'HDR_DOES_NOT_END_WITH', 'HDR_DOES_NOT_EQUAL', 'HDR_DOES_NOT_CONTAIN', 'HDR_CONTAINS', 'HDR_BEGINS_WITH', 'HDR_DOES_NOT_BEGIN_WITH']),
        ],
    )
    name_schema = properties.Schema(
        properties.Schema.STRING,
        _("Name of the cookie"),
        required=True,
        update_allowed=True,
    )
    match_case_schema = properties.Schema(
        properties.Schema.STRING,
        _("Case sensitivity to use for the match"),
        required=False,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['SENSITIVE', 'INSENSITIVE']),
        ],
    )
    value_schema = properties.Schema(
        properties.Schema.STRING,
        _("String value in the cookie"),
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'match_criteria',
        'name',
        'match_case',
        'value',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'match_criteria': match_criteria_schema,
        'name': name_schema,
        'match_case': match_case_schema,
        'value': value_schema,
    }



class StringMatch(object):
    # all schemas
    match_criteria_schema = properties.Schema(
        properties.Schema.STRING,
        _("Criterion to use for string matching the HTTP request"),
        required=True,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['REGEX_MATCH', 'DOES_NOT_END_WITH', 'ENDS_WITH', 'CONTAINS', 'EQUALS', 'DOES_NOT_BEGIN_WITH', 'DOES_NOT_EQUAL', 'REGEX_DOES_NOT_MATCH', 'DOES_NOT_CONTAIN', 'BEGINS_WITH']),
        ],
    )
    match_str_item_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=False,
    )
    match_str_schema = properties.Schema(
        properties.Schema.LIST,
        _("String value(s)"),
        schema=match_str_item_schema,
        required=False,
        update_allowed=True,
    )
    string_group_uuids_item_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=False,
    )
    string_group_uuids_schema = properties.Schema(
        properties.Schema.LIST,
        _("UUID of the string group(s) You can either provide UUID or provide a name with the prefix 'get_avi_uuid_for_name:', e.g., 'get_avi_uuid_for_name:my_obj_name'."),
        schema=string_group_uuids_item_schema,
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'match_criteria',
        'match_str',
        'string_group_uuids',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'match_criteria': match_criteria_schema,
        'match_str': match_str_schema,
        'string_group_uuids': string_group_uuids_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'string_group_uuids': 'stringgroup',
    }



class IpAddrGroup(AviResource):
    resource_name = "ipaddrgroup"
    # all schemas
    name_schema = properties.Schema(
        properties.Schema.STRING,
        _("Name of the IP address group"),
        required=True,
        update_allowed=True,
    )
    addrs_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=IpAddr.properties_schema,
        required=True,
        update_allowed=False,
    )
    addrs_schema = properties.Schema(
        properties.Schema.LIST,
        _("Configure IP address(es)"),
        schema=addrs_item_schema,
        required=False,
        update_allowed=True,
    )
    ranges_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=IpAddrRange.properties_schema,
        required=True,
        update_allowed=False,
    )
    ranges_schema = properties.Schema(
        properties.Schema.LIST,
        _("Configure IP address range(s)"),
        schema=ranges_item_schema,
        required=False,
        update_allowed=True,
    )
    prefixes_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=IpAddrPrefix.properties_schema,
        required=True,
        update_allowed=False,
    )
    prefixes_schema = properties.Schema(
        properties.Schema.LIST,
        _("Configure IP address prefix(es)"),
        schema=prefixes_item_schema,
        required=False,
        update_allowed=True,
    )
    country_codes_item_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=False,
    )
    country_codes_schema = properties.Schema(
        properties.Schema.LIST,
        _("Populate the IP address ranges from the geo database for this country"),
        schema=country_codes_item_schema,
        required=False,
        update_allowed=True,
    )
    apic_epg_name_schema = properties.Schema(
        properties.Schema.STRING,
        _("Populate IP addresses from members of this Cisco APIC EPG"),
        required=False,
        update_allowed=True,
    )
    ip_ports_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=IpAddrPort.properties_schema,
        required=True,
        update_allowed=False,
    )
    ip_ports_schema = properties.Schema(
        properties.Schema.LIST,
        _("Configure (IP address, port) tuple(s)"),
        schema=ip_ports_item_schema,
        required=False,
        update_allowed=True,
    )
    marathon_app_name_schema = properties.Schema(
        properties.Schema.STRING,
        _("Populate IP addresses from tasks of this Marathon app"),
        required=False,
        update_allowed=True,
    )
    marathon_service_port_schema = properties.Schema(
        properties.Schema.NUMBER,
        _("Task port associated with marathon service port. If Marathon app has multiple service ports, this is required. Else, the first task port is used"),
        required=False,
        update_allowed=True,
    )
    description_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'name',
        'addrs',
        'ranges',
        'prefixes',
        'country_codes',
        'apic_epg_name',
        'ip_ports',
        'marathon_app_name',
        'marathon_service_port',
        'description',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'name': name_schema,
        'addrs': addrs_schema,
        'ranges': ranges_schema,
        'prefixes': prefixes_schema,
        'country_codes': country_codes_schema,
        'apic_epg_name': apic_epg_name_schema,
        'ip_ports': ip_ports_schema,
        'marathon_app_name': marathon_app_name_schema,
        'marathon_service_port': marathon_service_port_schema,
        'description': description_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'ranges': getattr(IpAddrRange, 'field_references', {}),
        'prefixes': getattr(IpAddrPrefix, 'field_references', {}),
        'addrs': getattr(IpAddr, 'field_references', {}),
        'ip_ports': getattr(IpAddrPort, 'field_references', {}),
    }

    unique_keys = {
        'ranges': getattr(IpAddrRange, 'unique_keys', {}),
        'prefixes': getattr(IpAddrPrefix, 'unique_keys', {}),
        'addrs': getattr(IpAddr, 'unique_keys', {}),
        'ip_ports': getattr(IpAddrPort, 'unique_keys', {}),
    }



class IpAddrGroupAddrs(AviNestedResource):
    resource_name = "ipaddrgroup"
    nested_property_name = "addrs"

    parent_uuid_schema = properties.Schema(
        properties.Schema.STRING,
        _("UUID of ipaddrgroup."
          " You can also provide a name"
          " with the prefix 'get_avi_uuid_for_name:', e.g.,"
          " 'get_avi_uuid_for_name:my_obj_name'."),
        required=True,
        update_allowed=False,
    )
    addrs_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        required=True,
        update_allowed=False,
    )

    # properties list
    PROPERTIES = ('ipaddrgroup_uuid',
                  'addrs',
                 )

    # mapping of properties to their schemas
    properties_schema = {
        'ipaddrgroup_uuid': parent_uuid_schema,
        'addrs': addrs_item_schema,
    }

    # field references
    field_references = {
        'ipaddrgroup_uuid': 'ipaddrgroup',
        'addrs': getattr(IpAddr, 'field_references', {}),
    }


class HTTPStatusMatch(object):
    # all schemas
    match_criteria_schema = properties.Schema(
        properties.Schema.STRING,
        _("Criterion to use for matching the HTTP response status code(s)"),
        required=True,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['IS_NOT_IN', 'IS_IN']),
        ],
    )
    status_codes_item_schema = properties.Schema(
        properties.Schema.NUMBER,
        _(""),
        required=True,
        update_allowed=False,
    )
    status_codes_schema = properties.Schema(
        properties.Schema.LIST,
        _("HTTP response status code(s)"),
        schema=status_codes_item_schema,
        required=False,
        update_allowed=True,
    )
    ranges_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=HTTPStatusRange.properties_schema,
        required=True,
        update_allowed=False,
    )
    ranges_schema = properties.Schema(
        properties.Schema.LIST,
        _("HTTP response status code range(s)"),
        schema=ranges_item_schema,
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'match_criteria',
        'status_codes',
        'ranges',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'match_criteria': match_criteria_schema,
        'status_codes': status_codes_schema,
        'ranges': ranges_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'ranges': getattr(HTTPStatusRange, 'field_references', {}),
    }

    unique_keys = {
        'ranges': getattr(HTTPStatusRange, 'unique_keys', {}),
    }



class HostHdrMatch(object):
    # all schemas
    match_criteria_schema = properties.Schema(
        properties.Schema.STRING,
        _("Criterion to use for the host header value match"),
        required=True,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['HDR_ENDS_WITH', 'HDR_EQUALS', 'HDR_DOES_NOT_EXIST', 'HDR_EXISTS', 'HDR_DOES_NOT_END_WITH', 'HDR_DOES_NOT_EQUAL', 'HDR_DOES_NOT_CONTAIN', 'HDR_CONTAINS', 'HDR_BEGINS_WITH', 'HDR_DOES_NOT_BEGIN_WITH']),
        ],
    )
    match_case_schema = properties.Schema(
        properties.Schema.STRING,
        _("Case sensitivity to use for the match"),
        required=False,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['SENSITIVE', 'INSENSITIVE']),
        ],
    )
    value_item_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=False,
    )
    value_schema = properties.Schema(
        properties.Schema.LIST,
        _("String value(s) in the host header"),
        schema=value_item_schema,
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'match_criteria',
        'match_case',
        'value',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'match_criteria': match_criteria_schema,
        'match_case': match_case_schema,
        'value': value_schema,
    }



class KeyValue(object):
    # all schemas
    key_schema = properties.Schema(
        properties.Schema.STRING,
        _("Key"),
        required=True,
        update_allowed=True,
    )
    value_schema = properties.Schema(
        properties.Schema.STRING,
        _("Value"),
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'key',
        'value',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'key': key_schema,
        'value': value_schema,
    }



class QueryMatch(object):
    # all schemas
    match_criteria_schema = properties.Schema(
        properties.Schema.STRING,
        _("Criterion to use for matching the query in HTTP request URI"),
        required=True,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['QUERY_MATCH_CONTAINS']),
        ],
    )
    match_case_schema = properties.Schema(
        properties.Schema.STRING,
        _("Case sensitivity to use for the match"),
        required=False,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['SENSITIVE', 'INSENSITIVE']),
        ],
    )
    match_str_item_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=False,
    )
    match_str_schema = properties.Schema(
        properties.Schema.LIST,
        _("String value(s)"),
        schema=match_str_item_schema,
        required=False,
        update_allowed=True,
    )
    string_group_uuids_item_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=False,
    )
    string_group_uuids_schema = properties.Schema(
        properties.Schema.LIST,
        _("UUID of the string group(s) You can either provide UUID or provide a name with the prefix 'get_avi_uuid_for_name:', e.g., 'get_avi_uuid_for_name:my_obj_name'."),
        schema=string_group_uuids_item_schema,
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'match_criteria',
        'match_case',
        'match_str',
        'string_group_uuids',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'match_criteria': match_criteria_schema,
        'match_case': match_case_schema,
        'match_str': match_str_schema,
        'string_group_uuids': string_group_uuids_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'string_group_uuids': 'stringgroup',
    }



class HTTPVersionMatch(object):
    # all schemas
    match_criteria_schema = properties.Schema(
        properties.Schema.STRING,
        _("Criterion to use for HTTP version matching the version used in the HTTP request"),
        required=True,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['IS_NOT_IN', 'IS_IN']),
        ],
    )
    versions_item_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=False,
        constraints=[
            constraints.AllowedValues(['ZERO_NINE', 'ONE_ZERO', 'ONE_ONE']),
        ],
    )
    versions_schema = properties.Schema(
        properties.Schema.LIST,
        _("HTTP protocol version"),
        schema=versions_item_schema,
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'match_criteria',
        'versions',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'match_criteria': match_criteria_schema,
        'versions': versions_schema,
    }



class PathMatch(object):
    # all schemas
    match_criteria_schema = properties.Schema(
        properties.Schema.STRING,
        _("Criterion to use for matching the path in the HTTP request URI"),
        required=True,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['REGEX_MATCH', 'DOES_NOT_END_WITH', 'ENDS_WITH', 'CONTAINS', 'EQUALS', 'DOES_NOT_BEGIN_WITH', 'DOES_NOT_EQUAL', 'REGEX_DOES_NOT_MATCH', 'DOES_NOT_CONTAIN', 'BEGINS_WITH']),
        ],
    )
    match_case_schema = properties.Schema(
        properties.Schema.STRING,
        _("Case sensitivity to use for the matching"),
        required=False,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['SENSITIVE', 'INSENSITIVE']),
        ],
    )
    match_str_item_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=False,
    )
    match_str_schema = properties.Schema(
        properties.Schema.LIST,
        _("String values"),
        schema=match_str_item_schema,
        required=False,
        update_allowed=True,
    )
    string_group_uuids_item_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=False,
    )
    string_group_uuids_schema = properties.Schema(
        properties.Schema.LIST,
        _("UUID of the string group(s) You can either provide UUID or provide a name with the prefix 'get_avi_uuid_for_name:', e.g., 'get_avi_uuid_for_name:my_obj_name'."),
        schema=string_group_uuids_item_schema,
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'match_criteria',
        'match_case',
        'match_str',
        'string_group_uuids',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'match_criteria': match_criteria_schema,
        'match_case': match_case_schema,
        'match_str': match_str_schema,
        'string_group_uuids': string_group_uuids_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'string_group_uuids': 'stringgroup',
    }



class StringGroup(AviResource):
    resource_name = "stringgroup"
    # all schemas
    name_schema = properties.Schema(
        properties.Schema.STRING,
        _("Name of the string group"),
        required=True,
        update_allowed=True,
    )
    kv_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=KeyValue.properties_schema,
        required=True,
        update_allowed=False,
    )
    kv_schema = properties.Schema(
        properties.Schema.LIST,
        _("Configure Key:Value in the string group"),
        schema=kv_item_schema,
        required=False,
        update_allowed=True,
    )
    type_schema = properties.Schema(
        properties.Schema.STRING,
        _("Type of StringGroup."),
        required=True,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['SG_TYPE_KEYVAL', 'SG_TYPE_STRING']),
        ],
    )
    description_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'name',
        'kv',
        'type',
        'description',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'name': name_schema,
        'kv': kv_schema,
        'type': type_schema,
        'description': description_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'kv': getattr(KeyValue, 'field_references', {}),
    }

    unique_keys = {
        'kv': getattr(KeyValue, 'unique_keys', {}),
    }



class LocationHdrMatch(object):
    # all schemas
    match_criteria_schema = properties.Schema(
        properties.Schema.STRING,
        _("Criterion to use for matching location header value in the HTTP response"),
        required=True,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['HDR_ENDS_WITH', 'HDR_EQUALS', 'HDR_DOES_NOT_EXIST', 'HDR_EXISTS', 'HDR_DOES_NOT_END_WITH', 'HDR_DOES_NOT_EQUAL', 'HDR_DOES_NOT_CONTAIN', 'HDR_CONTAINS', 'HDR_BEGINS_WITH', 'HDR_DOES_NOT_BEGIN_WITH']),
        ],
    )
    match_case_schema = properties.Schema(
        properties.Schema.STRING,
        _("Case sensitivity to use for the match"),
        required=False,
        update_allowed=True,
        constraints=[
            constraints.AllowedValues(['SENSITIVE', 'INSENSITIVE']),
        ],
    )
    value_item_schema = properties.Schema(
        properties.Schema.STRING,
        _(""),
        required=True,
        update_allowed=False,
    )
    value_schema = properties.Schema(
        properties.Schema.LIST,
        _("String value(s) in the location header"),
        schema=value_item_schema,
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'match_criteria',
        'match_case',
        'value',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'match_criteria': match_criteria_schema,
        'match_case': match_case_schema,
        'value': value_schema,
    }



class MatchTarget(object):
    # all schemas
    client_ip_schema = properties.Schema(
        properties.Schema.MAP,
        _("Configure client ip addresses"),
        schema=IpAddrMatch.properties_schema,
        required=False,
        update_allowed=True,
    )
    vs_port_schema = properties.Schema(
        properties.Schema.MAP,
        _("Configure virtual service ports"),
        schema=PortMatch.properties_schema,
        required=False,
        update_allowed=True,
    )
    protocol_schema = properties.Schema(
        properties.Schema.MAP,
        _("Configure the type of HTTP protocol"),
        schema=ProtocolMatch.properties_schema,
        required=False,
        update_allowed=True,
    )
    method_schema = properties.Schema(
        properties.Schema.MAP,
        _("Configure HTTP methods"),
        schema=MethodMatch.properties_schema,
        required=False,
        update_allowed=True,
    )
    version_schema = properties.Schema(
        properties.Schema.MAP,
        _("Configure versions of the HTTP protocol"),
        schema=HTTPVersionMatch.properties_schema,
        required=False,
        update_allowed=True,
    )
    path_schema = properties.Schema(
        properties.Schema.MAP,
        _("Configure request paths"),
        schema=PathMatch.properties_schema,
        required=False,
        update_allowed=True,
    )
    query_schema = properties.Schema(
        properties.Schema.MAP,
        _("Configure request query"),
        schema=QueryMatch.properties_schema,
        required=False,
        update_allowed=True,
    )
    hdrs_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=HdrMatch.properties_schema,
        required=True,
        update_allowed=False,
    )
    hdrs_schema = properties.Schema(
        properties.Schema.LIST,
        _("Configure HTTP header(s)"),
        schema=hdrs_item_schema,
        required=False,
        update_allowed=True,
    )
    cookie_schema = properties.Schema(
        properties.Schema.MAP,
        _("Configure HTTP cookie(s)"),
        schema=CookieMatch.properties_schema,
        required=False,
        update_allowed=True,
    )
    host_hdr_schema = properties.Schema(
        properties.Schema.MAP,
        _("Configure the host header"),
        schema=HostHdrMatch.properties_schema,
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'client_ip',
        'vs_port',
        'protocol',
        'method',
        'version',
        'path',
        'query',
        'hdrs',
        'cookie',
        'host_hdr',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'client_ip': client_ip_schema,
        'vs_port': vs_port_schema,
        'protocol': protocol_schema,
        'method': method_schema,
        'version': version_schema,
        'path': path_schema,
        'query': query_schema,
        'hdrs': hdrs_schema,
        'cookie': cookie_schema,
        'host_hdr': host_hdr_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'client_ip': getattr(IpAddrMatch, 'field_references', {}),
        'protocol': getattr(ProtocolMatch, 'field_references', {}),
        'hdrs': getattr(HdrMatch, 'field_references', {}),
        'host_hdr': getattr(HostHdrMatch, 'field_references', {}),
        'vs_port': getattr(PortMatch, 'field_references', {}),
        'version': getattr(HTTPVersionMatch, 'field_references', {}),
        'cookie': getattr(CookieMatch, 'field_references', {}),
        'query': getattr(QueryMatch, 'field_references', {}),
        'path': getattr(PathMatch, 'field_references', {}),
        'method': getattr(MethodMatch, 'field_references', {}),
    }

    unique_keys = {
        'client_ip': getattr(IpAddrMatch, 'unique_keys', {}),
        'protocol': getattr(ProtocolMatch, 'unique_keys', {}),
        'hdrs': getattr(HdrMatch, 'unique_keys', {}),
        'host_hdr': getattr(HostHdrMatch, 'unique_keys', {}),
        'vs_port': getattr(PortMatch, 'unique_keys', {}),
        'version': getattr(HTTPVersionMatch, 'unique_keys', {}),
        'cookie': getattr(CookieMatch, 'unique_keys', {}),
        'query': getattr(QueryMatch, 'unique_keys', {}),
        'path': getattr(PathMatch, 'unique_keys', {}),
        'method': getattr(MethodMatch, 'unique_keys', {}),
    }



class ResponseMatchTarget(object):
    # all schemas
    client_ip_schema = properties.Schema(
        properties.Schema.MAP,
        _("Configure client ip addresses"),
        schema=IpAddrMatch.properties_schema,
        required=False,
        update_allowed=True,
    )
    vs_port_schema = properties.Schema(
        properties.Schema.MAP,
        _("Configure virtual service ports"),
        schema=PortMatch.properties_schema,
        required=False,
        update_allowed=True,
    )
    protocol_schema = properties.Schema(
        properties.Schema.MAP,
        _("Configure the type of HTTP protocol"),
        schema=ProtocolMatch.properties_schema,
        required=False,
        update_allowed=True,
    )
    method_schema = properties.Schema(
        properties.Schema.MAP,
        _("Configure HTTP methods"),
        schema=MethodMatch.properties_schema,
        required=False,
        update_allowed=True,
    )
    version_schema = properties.Schema(
        properties.Schema.MAP,
        _("Configure versions of the HTTP protocol"),
        schema=HTTPVersionMatch.properties_schema,
        required=False,
        update_allowed=True,
    )
    path_schema = properties.Schema(
        properties.Schema.MAP,
        _("Configure request paths"),
        schema=PathMatch.properties_schema,
        required=False,
        update_allowed=True,
    )
    query_schema = properties.Schema(
        properties.Schema.MAP,
        _("Configure request query"),
        schema=QueryMatch.properties_schema,
        required=False,
        update_allowed=True,
    )
    hdrs_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=HdrMatch.properties_schema,
        required=True,
        update_allowed=False,
    )
    hdrs_schema = properties.Schema(
        properties.Schema.LIST,
        _("Configure HTTP headers"),
        schema=hdrs_item_schema,
        required=False,
        update_allowed=True,
    )
    cookie_schema = properties.Schema(
        properties.Schema.MAP,
        _("Configure HTTP cookie(s)"),
        schema=CookieMatch.properties_schema,
        required=False,
        update_allowed=True,
    )
    host_hdr_schema = properties.Schema(
        properties.Schema.MAP,
        _("Configure the host header"),
        schema=HostHdrMatch.properties_schema,
        required=False,
        update_allowed=True,
    )
    loc_hdr_schema = properties.Schema(
        properties.Schema.MAP,
        _("Configure the location header"),
        schema=LocationHdrMatch.properties_schema,
        required=False,
        update_allowed=True,
    )
    status_schema = properties.Schema(
        properties.Schema.MAP,
        _("Configure the HTTP status code(s)"),
        schema=HTTPStatusMatch.properties_schema,
        required=False,
        update_allowed=True,
    )
    rsp_hdrs_item_schema = properties.Schema(
        properties.Schema.MAP,
        _(""),
        schema=HdrMatch.properties_schema,
        required=True,
        update_allowed=False,
    )
    rsp_hdrs_schema = properties.Schema(
        properties.Schema.LIST,
        _("Configure the HTTP headers in response"),
        schema=rsp_hdrs_item_schema,
        required=False,
        update_allowed=True,
    )

    # properties list
    PROPERTIES = (
        'client_ip',
        'vs_port',
        'protocol',
        'method',
        'version',
        'path',
        'query',
        'hdrs',
        'cookie',
        'host_hdr',
        'loc_hdr',
        'status',
        'rsp_hdrs',
    )

    # mapping of properties to their schemas
    properties_schema = {
        'client_ip': client_ip_schema,
        'vs_port': vs_port_schema,
        'protocol': protocol_schema,
        'method': method_schema,
        'version': version_schema,
        'path': path_schema,
        'query': query_schema,
        'hdrs': hdrs_schema,
        'cookie': cookie_schema,
        'host_hdr': host_hdr_schema,
        'loc_hdr': loc_hdr_schema,
        'status': status_schema,
        'rsp_hdrs': rsp_hdrs_schema,
    }

    # for supporting get_avi_uuid_by_name functionality
    field_references = {
        'status': getattr(HTTPStatusMatch, 'field_references', {}),
        'client_ip': getattr(IpAddrMatch, 'field_references', {}),
        'protocol': getattr(ProtocolMatch, 'field_references', {}),
        'hdrs': getattr(HdrMatch, 'field_references', {}),
        'loc_hdr': getattr(LocationHdrMatch, 'field_references', {}),
        'rsp_hdrs': getattr(HdrMatch, 'field_references', {}),
        'host_hdr': getattr(HostHdrMatch, 'field_references', {}),
        'vs_port': getattr(PortMatch, 'field_references', {}),
        'version': getattr(HTTPVersionMatch, 'field_references', {}),
        'cookie': getattr(CookieMatch, 'field_references', {}),
        'query': getattr(QueryMatch, 'field_references', {}),
        'path': getattr(PathMatch, 'field_references', {}),
        'method': getattr(MethodMatch, 'field_references', {}),
    }

    unique_keys = {
        'status': getattr(HTTPStatusMatch, 'unique_keys', {}),
        'client_ip': getattr(IpAddrMatch, 'unique_keys', {}),
        'protocol': getattr(ProtocolMatch, 'unique_keys', {}),
        'hdrs': getattr(HdrMatch, 'unique_keys', {}),
        'loc_hdr': getattr(LocationHdrMatch, 'unique_keys', {}),
        'rsp_hdrs': getattr(HdrMatch, 'unique_keys', {}),
        'host_hdr': getattr(HostHdrMatch, 'unique_keys', {}),
        'vs_port': getattr(PortMatch, 'unique_keys', {}),
        'version': getattr(HTTPVersionMatch, 'unique_keys', {}),
        'cookie': getattr(CookieMatch, 'unique_keys', {}),
        'query': getattr(QueryMatch, 'unique_keys', {}),
        'path': getattr(PathMatch, 'unique_keys', {}),
        'method': getattr(MethodMatch, 'unique_keys', {}),
    }



def resource_mapping():
    return {
        'Avi::LBaaS::IpAddrGroup': IpAddrGroup,
        'Avi::LBaaS::MicroServiceGroup': MicroServiceGroup,
        'Avi::LBaaS::StringGroup': StringGroup,
        'Avi::LBaaS::IpAddrGroup::Addr': IpAddrGroupAddrs,
    }

